<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title>@xjump</title>

      

      
          <script src="/slideout/1.0.1/slideout.min.js"></script>
          
          <link rel="stylesheet" href="/katex/0.10.1/katex.min.css">

          <script defer src="/katex/0.10.1/katex.min.js" ></script>
          <script defer src="/katex/0.10.1/contrib/mathtex-script-type.min.js" ></script>
              
          <script defer src="/katex/0.10.1/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
              
          
      

      
          <link rel="stylesheet" href="https:&#x2F;&#x2F;xjump.me&#x2F;site.css">
          
          <link rel="stylesheet" href="/katex/0.10.1/katex.min.css"  >
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="/" class="logo">@xjump</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;xjump.me">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;xjump.me&#x2F;categories">
                            Categories
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;xjump.me&#x2F;tags&#x2F;all">
                            Archive
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;xjump.me&#x2F;rss.xml">
                            RSS
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;xjump.me&#x2F;about">
                            About
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;xjump.me">@xjump</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;xjump.me">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;xjump.me&#x2F;categories">
                                    Categories
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;xjump.me&#x2F;tags&#x2F;all">
                                    Archive
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;xjump.me&#x2F;rss.xml">
                                    RSS
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;xjump.me&#x2F;about">
                                    About
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#1-nom-eating-data-byte-by-byte" class="toc-link">1 nom, eating data byte by byte</a>
                    
                </li>
                
                <li>
                    <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#2-parser-combinators" class="toc-link">2 Parser combinators</a>
                    
                </li>
                
                <li>
                    <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#3-making-new-parsers-with-function-combinators" class="toc-link">3 Making new parsers with function combinators</a>
                    
                </li>
                
                <li>
                    <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#4-combining-parsers" class="toc-link">4 Combining parsers</a>
                    
                </li>
                
                <li>
                    <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#5-streaming-complete" class="toc-link">5 Streaming &#x2F; Complete</a>
                    
                </li>
                
                <li>
                    <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-list-of-macros-parsers-and-combinators" class="toc-link">6 List of macros parsers and combinators</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-1-basic-elements" class="toc-link">6.1 Basic elements</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-2-choice-combinators" class="toc-link">6.2 Choice combinators</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-3-sequence-combinators" class="toc-link">6.3 Sequence combinators</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-4-applying-a-parser-multiple-times" class="toc-link">6.4 Applying a parser multiple times</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-5-integers" class="toc-link">6.5 Integers</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-6-streaming-related" class="toc-link">6.6 Streaming related</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-7-modifiers" class="toc-link">6.7 Modifiers</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-8-error-management-and-debugging" class="toc-link">6.8 Error management and debugging</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-9-text-parsing" class="toc-link">6.9 Text parsing</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-10-binary-format-parsing" class="toc-link">6.10 Binary format parsing</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-11-bit-stream-parsing" class="toc-link">6.11 Bit stream parsing</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-12-remaining-combinators" class="toc-link">6.12 Remaining combinators</a>
                        </li>
                        
                        <li>
                            <a href="https://xjump.me/20210106-rust-parser-combinator-nom/#6-13-character-test-functions" class="toc-link">6.13 Character test functions</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;xjump.me&#x2F;20210106-rust-parser-combinator-nom&#x2F;">Rust parser combinator - nom</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-01-06</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>This is the manual of <code>nom</code> from <a href="https://docs.rs/nom/6.0.1/nom/">docs.rs</a>.</p>
<h1 id="1-nom-eating-data-byte-by-byte">1 nom, eating data byte by byte</h1>
<p>nom is a parser combinator library with a focus on safe parsing,
streaming patterns, and as much as possible zero copy.</p>
<p>Example</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#c792ea;">extern crate</span><span style="color:#eeffff;"> nom</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">
  IResult</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">tag</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> take_while_m_n</span><span style="color:#89ddff;">},</span><span style="color:#eeffff;">
  combinator</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">map_res</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  sequence</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">tuple</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">#[</span><span style="color:#eeffff;">derive</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Debug</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">PartialEq</span><span style="color:#89ddff;">)]</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">pub </span><span style="font-style:italic;color:#c792ea;">struct </span><span style="color:#eeffff;">Color </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">
  </span><span style="color:#c792ea;">pub </span><span style="color:#eeffff;">red</span><span style="color:#89ddff;">:     </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">,</span><span style="color:#eeffff;">
  </span><span style="color:#c792ea;">pub </span><span style="color:#eeffff;">green</span><span style="color:#89ddff;">:   </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">,</span><span style="color:#eeffff;">
  </span><span style="color:#c792ea;">pub </span><span style="color:#eeffff;">blue</span><span style="color:#89ddff;">:    </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">,</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">from_hex</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">input</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#ffcb6b;">Result</span><span style="color:#89ddff;">&lt;</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">, std</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">num</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">ParseIntError</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">from_str_radix</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">, </span><span style="color:#f78c6c;">16</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">is_hex_digit</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">c</span><span style="color:#89ddff;">: </span><span style="font-style:italic;color:#c792ea;">char</span><span style="color:#89ddff;">) -&gt; </span><span style="font-style:italic;color:#c792ea;">bool </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">
  c</span><span style="color:#89ddff;">.</span><span style="color:#82aaff;">is_digit</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">16</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">hex_primary</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">input</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
  </span><span style="color:#82aaff;">map_res</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">
    </span><span style="color:#82aaff;">take_while_m_n</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">2</span><span style="color:#89ddff;">, </span><span style="color:#f78c6c;">2</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> is_hex_digit</span><span style="color:#89ddff;">),</span><span style="color:#eeffff;">
    from_hex</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">)(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">hex_color</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">input</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, Color</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">, _) = </span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">#</span><span style="color:#89ddff;">&quot;)(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">)?;</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">, (</span><span style="color:#eeffff;">red</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> green</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> blue</span><span style="color:#89ddff;">)) = </span><span style="color:#82aaff;">tuple</span><span style="color:#89ddff;">((</span><span style="color:#eeffff;">hex_primary</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> hex_primary</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> hex_primary</span><span style="color:#89ddff;">))(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">)?;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> Color </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;"> red</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> green</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> blue </span><span style="color:#89ddff;">}))</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">main</span><span style="color:#89ddff;">() {</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">hex_color</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">#2F14DF</span><span style="color:#89ddff;">&quot;), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&quot;&quot;,</span><span style="color:#eeffff;"> Color </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">
    red</span><span style="color:#89ddff;">: </span><span style="color:#f78c6c;">47</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
    green</span><span style="color:#89ddff;">: </span><span style="color:#f78c6c;">20</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
    blue</span><span style="color:#89ddff;">: </span><span style="color:#f78c6c;">223</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">})));</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre><span id="continue-reading"></span>
<p>The code is available on <a href="https://github.com/Geal/nom">Github</a></p>
<p>There are a few <a href="https://github.com/Geal/nom/tree/master/doc">guides</a> with more details
about <a href="https://github.com/Geal/nom/blob/master/doc/how_nom_macros_work.md">the design of nom macros</a>,
<a href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md">how to write parsers</a>,
or the <a href="https://github.com/Geal/nom/blob/master/doc/error_management.md">error management system</a>.
You can also check out the [recipes] module that contains examples of common patterns.</p>
<p><strong>Looking for a specific combinator? Read the
<a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">&quot;choose a combinator&quot; guide</a></strong></p>
<p>If you are upgrading to nom 5.0, please read the
<a href="https://github.com/Geal/nom/blob/master/doc/upgrading_to_nom_5.md">migration document</a>.</p>
<p>See also the <a href="https://github.com/Geal/nom/blob/master/doc/FAQ.md">FAQ</a>.</p>
<h1 id="2-parser-combinators">2 Parser combinators</h1>
<p>Parser combinators are an approach to parsers that is very different from
software like <a href="https://en.wikipedia.org/wiki/Lex_(software)">lex</a> and
<a href="https://en.wikipedia.org/wiki/Yacc">yacc</a>. Instead of writing the grammar
in a separate syntax and generating the corresponding code, you use very small
functions with very specific purposes, like &quot;take 5 bytes&quot;, or &quot;recognize the
word 'HTTP'&quot;, and assemble them in meaningful patterns like &quot;recognize
'HTTP', then a space, then a version&quot;.
The resulting code is small, and looks like the grammar you would have
written with other parser approaches.</p>
<p>This gives us a few advantages:</p>
<ul>
<li>The parsers are small and easy to write</li>
<li>The parsers components are easy to reuse (if they're general enough, please add them to nom!)</li>
<li>The parsers components are easy to test separately (unit tests and property-based tests)</li>
<li>The parser combination code looks close to the grammar you would have written</li>
<li>You can build partial parsers, specific to the data you need at the moment, and ignore the rest</li>
</ul>
<p>Here is an example of one such parser, to recognize text between parentheses:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">
  IResult</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  sequence</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">delimited</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#4a4a4a;">// see the &quot;streaming/complete&quot; paragraph lower for an explanation of these submodules</span><span style="color:#eeffff;">
  character</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">char</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">is_not</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">parens</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">input</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
  </span><span style="color:#82aaff;">delimited</span><span style="color:#89ddff;">(</span><span style="font-style:italic;color:#c792ea;">char</span><span style="color:#89ddff;">(&#39;</span><span style="color:#c3e88d;">(</span><span style="color:#89ddff;">&#39;), </span><span style="color:#82aaff;">is_not</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">)</span><span style="color:#89ddff;">&quot;), </span><span style="font-style:italic;color:#c792ea;">char</span><span style="color:#89ddff;">(&#39;</span><span style="color:#c3e88d;">)</span><span style="color:#89ddff;">&#39;))(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre>
<p>It defines a function named <code>parens</code> which will recognize a sequence of the
character <code>(</code>, the longest byte array not containing <code>)</code>, then the character
<code>)</code>, and will return the byte array in the middle.</p>
<p>Here is another parser, written without using nom's combinators this time:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#89ddff;">#[</span><span style="color:#eeffff;">macro_use</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">extern crate</span><span style="color:#eeffff;"> nom</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">, </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> Needed</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">main</span><span style="color:#89ddff;">() {</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">take4</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]&gt;{</span><span style="color:#eeffff;">
    </span><span style="font-style:italic;color:#c792ea;">if</span><span style="color:#eeffff;"> i</span><span style="color:#89ddff;">.</span><span style="color:#82aaff;">len</span><span style="color:#89ddff;">() &lt; </span><span style="color:#f78c6c;">4 </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">
      </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">(</span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Incomplete</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Needed</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">new</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">4</span><span style="color:#89ddff;">)))</span><span style="color:#eeffff;">
    </span><span style="color:#89ddff;">} </span><span style="font-style:italic;color:#c792ea;">else </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">
      </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">[</span><span style="color:#f78c6c;">4</span><span style="color:#89ddff;">..], &amp;</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">[</span><span style="color:#f78c6c;">0</span><span style="color:#89ddff;">..</span><span style="color:#f78c6c;">4</span><span style="color:#89ddff;">]))</span><span style="color:#eeffff;">
    </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre>
<p>This function takes a byte array as input, and tries to consume 4 bytes.
Writing all the parsers manually, like this, is dangerous, despite Rust's
safety features. There are still a lot of mistakes one can make. That's why
nom provides a list of function and macros to help in developing parsers.</p>
<p>With functions, you would write it like this:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">streaming</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">take</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">take4</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">input</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">  </span><span style="color:#82aaff;">take</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">4</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">)(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre>
<p>With macros, you would write it like this:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#89ddff;">#[</span><span style="color:#eeffff;">macro_use</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">extern crate</span><span style="color:#eeffff;"> nom</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">main</span><span style="color:#89ddff;">() {</span><span style="color:#eeffff;">
  named!</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">take4</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">take!</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">4</span><span style="color:#89ddff;">));</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre>
<p>nom has used macros for combinators from versions 1 to 4, and from version
5, it proposes new combinators as functions, but still allows the macros style
(macros have been rewritten to use the functions under the hood).
For new parsers, we recommend using the functions instead of macros, since
rustc messages will be much easier to understand.</p>
<p>A parser in nom is a function which, for an input type <code>I</code>, an output type <code>O</code>
and an optional error type <code>E</code>, will have the following signature:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">parser</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">input</span><span style="color:#89ddff;">:</span><span style="color:#eeffff;"> I</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;</span><span style="color:#eeffff;">I, O, E</span><span style="color:#89ddff;">&gt;;</span><span style="color:#eeffff;">
</span></code></pre>
<p>Or like this, if you don't want to specify a custom error type (it will be <code>(I, ErrorKind)</code> by default):</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">parser</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">input</span><span style="color:#89ddff;">:</span><span style="color:#eeffff;"> I</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;</span><span style="color:#eeffff;">I, O</span><span style="color:#89ddff;">&gt;;</span><span style="color:#eeffff;">
</span></code></pre>
<p><code>IResult</code> is an alias for the <code>Result</code> type:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">Needed</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">error</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">ErrorKind</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">type </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;</span><span style="color:#eeffff;">I</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> O</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> E </span><span style="color:#89ddff;">= (</span><span style="color:#eeffff;">I</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">ErrorKind</span><span style="color:#89ddff;">)&gt; = </span><span style="color:#ffcb6b;">Result</span><span style="color:#89ddff;">&lt;(</span><span style="color:#eeffff;">I, O</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">, </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">&lt;</span><span style="color:#eeffff;">E</span><span style="color:#89ddff;">&gt;&gt;;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">enum </span><span style="color:#eeffff;">Err&lt;E&gt; </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">
  Incomplete</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Needed</span><span style="color:#89ddff;">),</span><span style="color:#eeffff;">
  Error</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">E</span><span style="color:#89ddff;">),</span><span style="color:#eeffff;">
  Failure</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">E</span><span style="color:#89ddff;">),</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre>
<p>It can have the following values:</p>
<ul>
<li>A correct result <code>Ok((I,O))</code> with the first element being the remaining of the input (not parsed yet), and the second the output value;</li>
<li>An error <code>Err(Err::Error(c))</code> with <code>c</code> an error that can be built from the input position and a parser specific error</li>
<li>An error <code>Err(Err::Incomplete(Needed))</code> indicating that more input is necessary. <code>Needed</code> can indicate how much data is needed</li>
<li>An error <code>Err(Err::Failure(c))</code>. It works like the <code>Error</code> case, except it indicates an unrecoverable error: We cannot backtrack and test another parser</li>
</ul>
<p>Please refer to the <a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">&quot;choose a combinator&quot; guide</a> for an exhaustive list of parsers.
See also the rest of the documentation <a href="https://github.com/Geal/nom/blob/master/doc">here</a>.</p>
<h1 id="3-making-new-parsers-with-function-combinators">3 Making new parsers with function combinators</h1>
<p>nom is based on functions that generate parsers, with a signature like
this: <code>(arguments) -&gt; impl Fn(Input) -&gt; IResult&lt;Input, Output, Error&gt;</code>.
The arguments of a combinator can be direct values (like <code>take</code> which uses
a number of bytes or character as argument) or even other parsers (like
<code>delimited</code> which takes as argument 3 parsers, and returns the result of
the second one if all are successful).</p>
<p>Here are some examples:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">tag</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> take</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">abcd_parser</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
  </span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;)(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">) </span><span style="font-style:italic;color:#4a4a4a;">// will consume bytes if the input begins with &quot;abcd&quot;</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">take_10</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]&gt; {</span><span style="color:#eeffff;">
  </span><span style="color:#82aaff;">take</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">10</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">)(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">) </span><span style="font-style:italic;color:#4a4a4a;">// will consume and return 10 bytes of input</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre><h1 id="4-combining-parsers">4 Combining parsers</h1>
<p>There are higher level patterns, like the <strong><code>alt</code></strong> combinator, which
provides a choice between multiple parsers. If one branch fails, it tries
the next, and returns the result of the first parser that succeeds:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">branch</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">alt</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">tag</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#c792ea;">mut</span><span style="color:#eeffff;"> alt_tags </span><span style="color:#89ddff;">= </span><span style="color:#82aaff;">alt</span><span style="color:#89ddff;">((</span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;), </span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">efgh</span><span style="color:#89ddff;">&quot;)));</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">alt_tags</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcdxxx</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">xxx</span><span style="color:#89ddff;">&quot;[..], &amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;[..])));</span><span style="color:#eeffff;">
assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">alt_tags</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">efghxxx</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">xxx</span><span style="color:#89ddff;">&quot;[..], &amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">efgh</span><span style="color:#89ddff;">&quot;[..])));</span><span style="color:#eeffff;">
assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">alt_tags</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">ijklxxx</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Err</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Error</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">ijklxxx</span><span style="color:#89ddff;">&quot;[..], </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">error</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">ErrorKind</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Tag</span><span style="color:#89ddff;">))));</span><span style="color:#eeffff;">
</span></code></pre>
<p>The <strong><code>opt</code></strong> combinator makes a parser optional. If the child parser returns
an error, <strong><code>opt</code></strong> will still succeed and return None:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">combinator</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">opt</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">tag</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">abcd_opt</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, </span><span style="color:#ffcb6b;">Option</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]&gt;&gt; {</span><span style="color:#eeffff;">
  </span><span style="color:#82aaff;">opt</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;))(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">abcd_opt</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcdxxx</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">xxx</span><span style="color:#89ddff;">&quot;[..], </span><span style="color:#ffcb6b;">Some</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;[..]))));</span><span style="color:#eeffff;">
assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">abcd_opt</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">efghxxx</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">efghxxx</span><span style="color:#89ddff;">&quot;[..], </span><span style="color:#ffcb6b;">None</span><span style="color:#89ddff;">)));</span><span style="color:#eeffff;">
</span></code></pre>
<p><strong><code>many0</code></strong> applies a parser 0 or more times, and returns a vector of the aggregated results:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#89ddff;">#[</span><span style="color:#eeffff;">macro_use</span><span style="color:#89ddff;">] </span><span style="color:#c792ea;">extern crate</span><span style="color:#eeffff;"> nom</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">#[</span><span style="color:#eeffff;">cfg</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">feature </span><span style="color:#89ddff;">= &quot;</span><span style="color:#c3e88d;">alloc</span><span style="color:#89ddff;">&quot;)]</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">main</span><span style="color:#89ddff;">() {</span><span style="color:#eeffff;">
  </span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">multi</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">many0</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">tag</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
  </span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">std</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">str</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">multi</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, </span><span style="color:#ffcb6b;">Vec</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">&gt;&gt; {</span><span style="color:#eeffff;">
    </span><span style="color:#82aaff;">many0</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;))(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let</span><span style="color:#eeffff;"> a </span><span style="color:#89ddff;">= &quot;</span><span style="color:#c3e88d;">abcdef</span><span style="color:#89ddff;">&quot;;</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let</span><span style="color:#eeffff;"> b </span><span style="color:#89ddff;">= &quot;</span><span style="color:#c3e88d;">abcdabcdef</span><span style="color:#89ddff;">&quot;;</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let</span><span style="color:#eeffff;"> c </span><span style="color:#89ddff;">= &quot;</span><span style="color:#c3e88d;">azerty</span><span style="color:#89ddff;">&quot;;</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">multi</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">a</span><span style="color:#89ddff;">), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&quot;</span><span style="color:#c3e88d;">ef</span><span style="color:#89ddff;">&quot;,     </span><span style="color:#eeffff;">vec!</span><span style="color:#89ddff;">[&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;])));</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">multi</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">b</span><span style="color:#89ddff;">), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&quot;</span><span style="color:#c3e88d;">ef</span><span style="color:#89ddff;">&quot;,     </span><span style="color:#eeffff;">vec!</span><span style="color:#89ddff;">[&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;, &quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;])));</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">multi</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">c</span><span style="color:#89ddff;">), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&quot;</span><span style="color:#c3e88d;">azerty</span><span style="color:#89ddff;">&quot;, </span><span style="color:#ffcb6b;">Vec</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">new</span><span style="color:#89ddff;">())));</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">[</span><span style="color:#82aaff;">cfg</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">not</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">feature </span><span style="color:#89ddff;">= &quot;</span><span style="color:#c3e88d;">alloc</span><span style="color:#89ddff;">&quot;))]</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">main</span><span style="color:#89ddff;">() {}</span><span style="color:#eeffff;">
</span></code></pre>
<p>Here are some basic combining macros available:</p>
<ul>
<li><strong><code>opt</code></strong>: Will make the parser optional (if it returns the <code>O</code> type, the new parser returns <code>Option&lt;O&gt;</code>)</li>
<li><strong><code>many0</code></strong>: Will apply the parser 0 or more times (if it returns the <code>O</code> type, the new parser returns <code>Vec&lt;O&gt;</code>)</li>
<li><strong><code>many1</code></strong>: Will apply the parser 1 or more times</li>
</ul>
<p>There are more complex (and more useful) parsers like <code>tuple!</code>, which is
used to apply a series of parsers then assemble their results.</p>
<p>Example with <code>tuple</code>:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#89ddff;">#[</span><span style="color:#eeffff;">macro_use</span><span style="color:#89ddff;">] </span><span style="color:#c792ea;">extern crate</span><span style="color:#eeffff;"> nom</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">main</span><span style="color:#89ddff;">() {</span><span style="color:#eeffff;">
  </span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">error</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">ErrorKind</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> Needed</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  number</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">streaming</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">be_u16</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;">
  bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">streaming</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">tag</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> take</span><span style="color:#89ddff;">},</span><span style="color:#eeffff;">
  sequence</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">tuple</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#c792ea;">mut</span><span style="color:#eeffff;"> tpl </span><span style="color:#89ddff;">= </span><span style="color:#82aaff;">tuple</span><span style="color:#89ddff;">((</span><span style="color:#eeffff;">be_u16</span><span style="color:#89ddff;">, </span><span style="color:#82aaff;">take</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">3</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">), </span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">fg</span><span style="color:#89ddff;">&quot;)));</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">
   </span><span style="color:#82aaff;">tpl</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcdefgh</span><span style="color:#89ddff;">&quot;[..]),</span><span style="color:#eeffff;">
   </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((</span><span style="color:#eeffff;">
     </span><span style="color:#89ddff;">&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">h</span><span style="color:#89ddff;">&quot;[..],</span><span style="color:#eeffff;">
     </span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">0x6162</span><span style="font-style:italic;color:#c792ea;">u16</span><span style="color:#89ddff;">, &amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">cde</span><span style="color:#89ddff;">&quot;[..], &amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">fg</span><span style="color:#89ddff;">&quot;[..])</span><span style="color:#eeffff;">
   </span><span style="color:#89ddff;">))</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">);</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">tpl</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcde</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Err</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Incomplete</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Needed</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">new</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">2</span><span style="color:#89ddff;">))));</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let</span><span style="color:#eeffff;"> input </span><span style="color:#89ddff;">= &amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcdejk</span><span style="color:#89ddff;">&quot;[..];</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">tpl</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">), </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Err</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Error</span><span style="color:#89ddff;">((&amp;</span><span style="color:#eeffff;">input</span><span style="color:#89ddff;">[</span><span style="color:#f78c6c;">5</span><span style="color:#89ddff;">..], </span><span style="color:#eeffff;">ErrorKind</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Tag</span><span style="color:#89ddff;">))));</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre>
<p>But you can also use a sequence of combinators written in imperative style,
thanks to the <code>?</code> operator:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#89ddff;">#[</span><span style="color:#eeffff;">macro_use</span><span style="color:#89ddff;">] </span><span style="color:#c792ea;">extern crate</span><span style="color:#eeffff;"> nom</span><span style="color:#89ddff;">;</span><span style="color:#eeffff;">
</span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">main</span><span style="color:#89ddff;">() {</span><span style="color:#eeffff;">
  </span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">tag</span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">[</span><span style="color:#82aaff;">derive</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Debug</span><span style="color:#89ddff;">, </span><span style="color:#ffcb6b;">PartialEq</span><span style="color:#89ddff;">)]</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">struct </span><span style="color:#eeffff;">A </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">
    a</span><span style="color:#89ddff;">: </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">,</span><span style="color:#eeffff;">
    b</span><span style="color:#89ddff;">: </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">ret_int1</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">:&amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">&gt; { </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">,</span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">)) }</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">ret_int2</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">:&amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, </span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">&gt; { </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">,</span><span style="color:#f78c6c;">2</span><span style="color:#89ddff;">)) }</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">f</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, A</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
    </span><span style="font-style:italic;color:#4a4a4a;">// if successful, the parser returns `Ok((remaining_input, output_value))` that we can destructure</span><span style="color:#eeffff;">
    </span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">, _) = </span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;)(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)?;</span><span style="color:#eeffff;">
    </span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> a</span><span style="color:#89ddff;">) = </span><span style="color:#82aaff;">ret_int1</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)?;</span><span style="color:#eeffff;">
    </span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">, _) = </span><span style="color:#82aaff;">tag</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">efgh</span><span style="color:#89ddff;">&quot;)(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)?;</span><span style="color:#eeffff;">
    </span><span style="font-style:italic;color:#c792ea;">let </span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> b</span><span style="color:#89ddff;">) = </span><span style="color:#82aaff;">ret_int2</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)?;</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
    </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> A </span><span style="color:#89ddff;">{</span><span style="color:#eeffff;"> a</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> b </span><span style="color:#89ddff;">}))</span><span style="color:#eeffff;">
  </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
  </span><span style="font-style:italic;color:#c792ea;">let</span><span style="color:#eeffff;"> r </span><span style="color:#89ddff;">= </span><span style="color:#82aaff;">f</span><span style="color:#89ddff;">(</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcdefghX</span><span style="color:#89ddff;">&quot;);</span><span style="color:#eeffff;">
  assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">r</span><span style="color:#89ddff;">, </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">X</span><span style="color:#89ddff;">&quot;[..],</span><span style="color:#eeffff;"> A</span><span style="color:#89ddff;">{</span><span style="color:#eeffff;">a</span><span style="color:#89ddff;">: </span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">,</span><span style="color:#eeffff;"> b</span><span style="color:#89ddff;">: </span><span style="color:#f78c6c;">2</span><span style="color:#89ddff;">})));</span><span style="color:#eeffff;">
</span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span></code></pre><h1 id="5-streaming-complete">5 Streaming / Complete</h1>
<p>Some of nom's modules have <code>streaming</code> or <code>complete</code> submodules. They hold
different variants of the same combinators.</p>
<p>A streaming parser assumes that we might not have all of the input data.
This can happen with some network protocol or large file parsers, where the
input buffer can be full and need to be resized or refilled.</p>
<p>A complete parser assumes that we already have all of the input data.
This will be the common case with small files that can be read entirely to
memory.</p>
<p>Here is how it works in practice:</p>
<pre style="background-color:#212121;">
<code class="language-rust" data-lang="rust"><span style="color:#eeffff;"> </span><span style="color:#c792ea;">use </span><span style="color:#eeffff;">nom</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">
   IResult</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">
   </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">
   Needed</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">
   error</span><span style="color:#89ddff;">::{</span><span style="color:#eeffff;">
     Error</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">
     ErrorKind</span><span style="color:#eeffff;">
   </span><span style="color:#89ddff;">}, </span><span style="color:#eeffff;">
   bytes</span><span style="color:#89ddff;">, </span><span style="color:#eeffff;">
   character</span><span style="color:#eeffff;">
 </span><span style="color:#89ddff;">};</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">take_streaming</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]&gt; {</span><span style="color:#eeffff;">
   bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">streaming</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">take</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">4</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">)(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
 </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">take_complete</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="color:#eeffff;">[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#eeffff;">]</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;[</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">]&gt; {</span><span style="color:#eeffff;">
   bytes</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">take</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">4</span><span style="font-style:italic;color:#c792ea;">u8</span><span style="color:#89ddff;">)(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
 </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// both parsers will take 4 bytes as expected</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">take_streaming</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcde</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">e</span><span style="color:#89ddff;">&quot;[..], &amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;[..])));</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">take_complete</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcde</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">e</span><span style="color:#89ddff;">&quot;[..], &amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;[..])));</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// if the input is smaller than 4 bytes, the streaming parser</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// will return `Incomplete` to indicate that we need more data</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">take_streaming</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abc</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">(</span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Incomplete</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Needed</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">new</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">))));</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// but the complete parser will return an error</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">take_complete</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abc</span><span style="color:#89ddff;">&quot;[..]), </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">(</span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Error</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Error</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">new</span><span style="color:#89ddff;">(&amp;</span><span style="font-style:italic;color:#c792ea;">b</span><span style="color:#89ddff;">&quot;</span><span style="color:#c3e88d;">abc</span><span style="color:#89ddff;">&quot;[..], </span><span style="color:#eeffff;">ErrorKind</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Eof</span><span style="color:#89ddff;">))));</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// the alpha0 function recognizes 0 or more alphabetic characters</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">alpha0_streaming</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
   character</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">streaming</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">alpha0</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
 </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#c792ea;">fn </span><span style="color:#82aaff;">alpha0_complete</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">i</span><span style="color:#89ddff;">: &amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">) -&gt; </span><span style="color:#eeffff;">IResult</span><span style="color:#89ddff;">&lt;&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#eeffff;">, </span><span style="color:#89ddff;">&amp;</span><span style="font-style:italic;color:#c792ea;">str</span><span style="color:#89ddff;">&gt; {</span><span style="color:#eeffff;">
   character</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">complete</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">alpha0</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">i</span><span style="color:#89ddff;">)</span><span style="color:#eeffff;">
 </span><span style="color:#89ddff;">}</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// if there&#39;s a clear limit to the recognized characters, both </span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// parsers work the same way</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">alpha0_streaming</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd;</span><span style="color:#89ddff;">&quot;), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&quot;</span><span style="color:#c3e88d;">;</span><span style="color:#89ddff;">&quot;, &quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;)));</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">alpha0_complete</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd;</span><span style="color:#89ddff;">&quot;), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&quot;</span><span style="color:#c3e88d;">;</span><span style="color:#89ddff;">&quot;, &quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;)));</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// but when there&#39;s no limit, the streaming version returns </span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// `Incomplete`, because it cannot know if more input data </span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// should be recognized. The whole input could be &quot;abcd;&quot;, </span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// or &quot;abcde;&quot;</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">alpha0_streaming</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;), </span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">(</span><span style="color:#ffcb6b;">Err</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">Incomplete</span><span style="color:#89ddff;">(</span><span style="color:#eeffff;">Needed</span><span style="color:#89ddff;">::</span><span style="color:#eeffff;">new</span><span style="color:#89ddff;">(</span><span style="color:#f78c6c;">1</span><span style="color:#89ddff;">))));</span><span style="color:#eeffff;">
</span><span style="color:#eeffff;">
 </span><span style="font-style:italic;color:#4a4a4a;">// while the complete version knows that all of the data is there</span><span style="color:#eeffff;">
 assert_eq!</span><span style="color:#89ddff;">(</span><span style="color:#82aaff;">alpha0_complete</span><span style="color:#89ddff;">(&quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;), </span><span style="color:#ffcb6b;">Ok</span><span style="color:#89ddff;">((&quot;&quot;, &quot;</span><span style="color:#c3e88d;">abcd</span><span style="color:#89ddff;">&quot;)));</span><span style="color:#eeffff;">
</span></code></pre>
<p><strong>Going further:</strong> Read the <a href="https://github.com/Geal/nom/tree/master/doc">guides</a>,
check out the <a href="https://docs.rs/nom/6.0.1/nom/recipes/index.html">recipes</a>!</p>
<h1 id="6-list-of-macros-parsers-and-combinators">6 List of macros parsers and combinators</h1>
<p><strong>Note</strong>: this list is meant to provide a nicer way to find a nom macros than reading through the
documentation on docs.rs, since rustdoc puts all the macros at the top level. Function combinators
are organized in module so they are a bit easier to find.</p>
<h2 id="6-1-basic-elements">6.1 Basic elements</h2>
<p>Those are used to recognize the lowest level elements of your grammar, like, &quot;here is a dot&quot;, or &quot;here is an big endian integer&quot;.</p>
<table><thead><tr><th>combinator</th><th>usage</th><th>input</th><th>output</th><th>comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.char.html">char</a></td><td><code>char!('a')</code></td><td><code>&quot;abc&quot;</code></td><td><code>Ok((&quot;bc&quot;, 'a'))</code></td><td>Matches one character (works with non ASCII chars too)</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.is_a.html">is_a</a></td><td><code> is_a!(&quot;ab&quot;)</code></td><td><code>&quot;ababc&quot;</code></td><td><code>Ok((&quot;c&quot;, &quot;abab&quot;))</code></td><td>Matches a sequence of any of the characters passed as arguments</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.is_not.html">is_not</a></td><td><code>is_not!(&quot;cd&quot;)</code></td><td><code>&quot;ababc&quot;</code></td><td><code>Ok((&quot;c&quot;, &quot;abab&quot;))</code></td><td>Matches a sequence of none of the characters passed as arguments</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.one_of.html">one_of</a></td><td><code>one_of!(&quot;abc&quot;)</code></td><td><code>&quot;abc&quot;</code></td><td><code>Ok((&quot;bc&quot;, 'a'))</code></td><td>Matches one of the provided characters (works with non ASCII characters too)</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.none_of.html">none_of</a></td><td><code>none_of!(&quot;abc&quot;)</code></td><td><code>&quot;xyab&quot;</code></td><td><code>Ok((&quot;yab&quot;, 'x'))</code></td><td>Matches anything but the provided characters</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.tag.html">tag</a></td><td><code>tag!(&quot;hello&quot;)</code></td><td><code>&quot;hello world&quot;</code></td><td><code>Ok((&quot; world&quot;, &quot;hello&quot;))</code></td><td>Recognizes a specific suite of characters or bytes</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.tag_no_case.html">tag_no_case</a></td><td><code>tag_no_case!(&quot;hello&quot;)</code></td><td><code>&quot;HeLLo World&quot;</code></td><td><code>Ok((&quot; World&quot;, &quot;HeLLo&quot;))</code></td><td>Case insensitive comparison. Note that case insensitive comparison is not well defined for unicode, and that you might have bad surprises</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.take.html">take</a></td><td><code>take!(4)</code></td><td><code>&quot;hello&quot;</code></td><td><code>Ok((&quot;o&quot;, &quot;hell&quot;))</code></td><td>Takes a specific number of bytes or characters</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.take_while.html">take_while</a></td><td><code>take_while!(is_alphabetic)</code></td><td><code>&quot;abc123&quot;</code></td><td><code>Ok((&quot;123&quot;, &quot;abc&quot;))</code></td><td>Returns the longest list of bytes for which the provided function returns true. <code>take_while1</code> does the same, but must return at least one character</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.take_till.html">take_till</a></td><td><code>take_till!(is_alphabetic)</code></td><td><code>&quot;123abc&quot;</code></td><td><code>Ok((&quot;abc&quot;, &quot;123&quot;))</code></td><td>Returns the longest list of bytes or characters until the provided function returns true. <code>take_till1</code> does the same, but must return at least one character. This is the reverse behaviour from <code>take_while</code>: <code>take_till!(f)</code> is equivalent to <code>take_while!(\|c\| !f(c))</code></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.take_until.html">take_until</a></td><td><code>take_until!(&quot;world&quot;)</code></td><td><code>&quot;Hello world&quot;</code></td><td><code>Ok((&quot;world&quot;, &quot;Hello &quot;))</code></td><td>Returns the longest list of bytes or characters until the provided tag is found. <code>take_until1</code> does the same, but must return at least one character</td></tr>
</tbody></table>
<h2 id="6-2-choice-combinators">6.2 Choice combinators</h2>
<table><thead><tr><th>combinator</th><th>usage</th><th>input</th><th>output</th><th>comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.alt.html">alt</a></td><td><code>alt!(tag!(&quot;ab&quot;) \| tag!(&quot;cd&quot;))</code></td><td><code>&quot;cdef&quot;</code></td><td><code>Ok((&quot;ef&quot;, &quot;cd&quot;))</code></td><td>Try a list of parsers and return the result of the first successful one</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.switch.html">switch</a></td><td><code>switch!(take!(2), &quot;ab&quot; =&gt; tag!(&quot;XYZ&quot;) \| &quot;cd&quot; =&gt; tag!(&quot;123&quot;))</code></td><td><code>&quot;cd1234&quot;</code></td><td><code>Ok((&quot;4&quot;, &quot;123&quot;))</code></td><td>Choose the next parser depending on the result of the first one, if successful, and returns the result of the second parser</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.permutation.html">permutation</a></td><td><code>permutation!(tag!(&quot;ab&quot;), tag!(&quot;cd&quot;), tag!(&quot;12&quot;))</code></td><td><code>&quot;cd12abc&quot;</code></td><td><code>Ok((&quot;c&quot;, (&quot;ab&quot;, &quot;cd&quot;, &quot;12&quot;))</code></td><td>Succeeds when all its child parser have succeeded, whatever the order</td></tr>
</tbody></table>
<h2 id="6-3-sequence-combinators">6.3 Sequence combinators</h2>
<table><thead><tr><th>combinator</th><th>usage</th><th>input</th><th>output</th><th>comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.delimited.html">delimited</a></td><td><code>delimited!(char!('('), take!(2), char!(')'))</code></td><td><code>&quot;(ab)cd&quot;</code></td><td><code>Ok((&quot;cd&quot;, &quot;ab&quot;))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.preceded.html">preceded</a></td><td><code>preceded!(tag!(&quot;ab&quot;), tag!(&quot;XY&quot;))</code></td><td><code>&quot;abXYZ&quot;</code></td><td><code>Ok((&quot;Z&quot;, &quot;XY&quot;))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.terminated.html">terminated</a></td><td><code>terminated!(tag!(&quot;ab&quot;), tag!(&quot;XY&quot;))</code></td><td><code>&quot;abXYZ&quot;</code></td><td><code>Ok((&quot;Z&quot;, &quot;ab&quot;))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.pair.html">pair</a></td><td><code>pair!(tag!(&quot;ab&quot;), tag!(&quot;XY&quot;))</code></td><td><code>&quot;abXYZ&quot;</code></td><td><code>Ok((&quot;Z&quot;, (&quot;ab&quot;, &quot;XY&quot;)))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.separated_pair.html">separated_pair</a></td><td><code>separated_pair!(tag!(&quot;hello&quot;), char!(','), tag!(&quot;world&quot;))</code></td><td><code>&quot;hello,world!&quot;</code></td><td><code>Ok((&quot;!&quot;, (&quot;hello&quot;, &quot;world&quot;)))</code></td><td></td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.tuple.html">tuple</a></td><td><code>tuple!(tag!(&quot;ab&quot;), tag!(&quot;XY&quot;), take!(1))</code></td><td><code>&quot;abXYZ!&quot;</code></td><td><code>Ok((&quot;!&quot;, (&quot;ab&quot;, &quot;XY&quot;, &quot;Z&quot;)))</code></td><td>Chains parsers and assemble the sub results in a tuple. You can use as many child parsers as you can put elements in a tuple</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.do_parse.html">do_parse</a></td><td><code>do_parse!(tag: take!(2) &gt;&gt; length: be_u8 &gt;&gt; data: take!(length) &gt;&gt; (Buffer { tag: tag, data: data}) )</code></td><td><code>&amp;[0, 0, 3, 1, 2, 3][..]</code></td><td><code>Buffer { tag: &amp;[0, 0][..], data: &amp;[1, 2, 3][..] }</code></td><td><code>do_parse</code> applies sub parsers in a sequence. It can store intermediary results and make them available for later parsers</td></tr>
</tbody></table>
<h2 id="6-4-applying-a-parser-multiple-times">6.4 Applying a parser multiple times</h2>
<table><thead><tr><th>combinator</th><th>usage</th><th>input</th><th>output</th><th>comment</th></tr></thead><tbody>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.count.html">count</a></td><td><code>count!(take!(2), 3)</code></td><td><code>&quot;abcdefgh&quot;</code></td><td><code>Ok((&quot;gh&quot;, vec!(&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;)))</code></td><td>Applies the child parser a specified number of times</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.many0.html">many0</a></td><td><code>many0!(tag!(&quot;ab&quot;))</code></td><td><code>&quot;abababc&quot;</code></td><td><code>Ok((&quot;c&quot;, vec!(&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;)))</code></td><td>Applies the parser 0 or more times and returns the list of results in a Vec. <code>many1</code> does the same operation but must return at least one element</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.many_m_n.html">many_m_n</a></td><td><code>many_m_n!(1, 3, tag!(&quot;ab&quot;))</code></td><td><code>&quot;ababc&quot;</code></td><td><code>Ok((&quot;c&quot;, vec!(&quot;ab&quot;, &quot;ab&quot;)))</code></td><td>Applies the parser between m and n times (n included) and returns the list of results in a Vec</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.many_till.html">many_till</a></td><td><code>many_till!(tag!( &quot;ab&quot; ), tag!( &quot;ef&quot; ))</code></td><td><code>&quot;ababefg&quot;</code></td><td><code>Ok((&quot;g&quot;, (vec!(&quot;ab&quot;, &quot;ab&quot;), &quot;ef&quot;)))</code></td><td>Applies the first parser until the second applies. Returns a tuple containing the list of results from the first in a Vec and the result of the second</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.separated_list.html">separated_list</a></td><td><code>separated_list!(tag!(&quot;,&quot;), tag!(&quot;ab&quot;))</code></td><td><code>&quot;ab,ab,ab.&quot;</code></td><td><code>Ok((&quot;.&quot;, vec!(&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;)))</code></td><td><code>separated_nonempty_list</code> works like <code>separated_list</code> but must returns at least one element</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.fold_many0.html">fold_many0</a></td><td><code>fold_many0!(be_u8, 0, \|acc, item\| acc + item)</code></td><td><code>[1, 2, 3]</code></td><td><code>Ok(([], 6))</code></td><td>Applies the parser 0 or more times and folds the list of return values. The <code>fold_many1</code> version must apply the child parser at least one time</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.fold_many_m_n.html">fold_many_m_n</a></td><td><code>fold_many_m_n!(1, 2, be_u8, 0, \|acc, item\| acc + item)</code></td><td><code>[1, 2, 3]</code></td><td><code>Ok(([3], 3))</code></td><td>Applies the parser between m and n times (n included) and folds the list of return value</td></tr>
<tr><td><a href="https://docs.rs/nom/latest/nom/macro.length_count.html">length_count</a></td><td><code>length_count!(number, tag!(&quot;ab&quot;))</code></td><td><code>&quot;2ababab&quot;</code></td><td><code>Ok((&quot;ab&quot;, vec!(&quot;ab&quot;, &quot;ab&quot;)))</code></td><td>Gets a number from the first parser, then applies the second parser that many times</td></tr>
</tbody></table>
<h2 id="6-5-integers">6.5 Integers</h2>
<p>Parsing integers from binary formats can be done in two ways: With parser functions, or combinators with configurable endianness:</p>
<ul>
<li><strong>configurable endianness:</strong> <code>i16!</code>, <code>i32!</code>, <code>i64!</code>, <code>u16!</code>, <code>u32!</code>, <code>u64!</code> are combinators that take as argument a <code>nom::Endianness</code>, like this: <code>i16!(endianness)</code>. If the parameter is <code>nom::Endianness::Big</code>, parse a big endian <code>i16</code> integer, otherwise a little endian <code>i16</code> integer.</li>
<li><strong>fixed endianness</strong>: The functions are prefixed by <code>be_</code> for big endian numbers, and by <code>le_</code> for little endian numbers, and the suffix is the type they parse to. As an example, <code>be_u32</code> parses a big endian unsigned integer stored in 32 bits.</li>
<li><code>be_f32</code>, <code>be_f64</code>, <code>le_f32</code>, <code>le_f64</code>: Recognize floating point numbers</li>
<li><code>be_i8</code>, <code>be_i16</code>, <code>be_i24</code>, <code>be_i32</code>, <code>be_i64</code>: Big endian signed integers</li>
<li><code>be_u8</code>, <code>be_u16</code>, <code>be_u24</code>, <code>be_u32</code>, <code>be_u64</code>: Big endian unsigned integers</li>
<li><code>le_i8</code>, <code>le_i16</code>, <code>le_i24</code>, <code>le_i32</code>, <code>le_i64</code>: Little endian signed integers</li>
<li><code>le_u8</code>, <code>le_u16</code>, <code>le_u24</code>, <code>le_u32</code>, <code>le_u64</code>: Little endian unsigned integers</li>
</ul>
<h2 id="6-6-streaming-related">6.6 Streaming related</h2>
<ul>
<li><code>eof!</code>: Returns its input if it is at the end of input data</li>
<li><code>complete!</code>: Replaces an <code>Incomplete</code> returned by the child parser with an <code>Error</code></li>
</ul>
<h2 id="6-7-modifiers">6.7 Modifiers</h2>
<ul>
<li><code>cond!</code>: Conditional combinator. Wraps another parser and calls it if the condition is met</li>
<li><code>flat_map!</code>: </li>
<li><code>map!</code>: Maps a function on the result of a parser</li>
<li><code>map_opt!</code>: Maps a function returning an <code>Option</code> on the output of a parser</li>
<li><code>map_res!</code>: Maps a function returning a <code>Result</code> on the output of a parser</li>
<li><code>not!</code>: Returns a result only if the embedded parser returns <code>Error</code> or <code>Incomplete</code>. Does not consume the input</li>
<li><code>opt!</code>: Make the underlying parser optional</li>
<li><code>opt_res!</code>: Make the underlying parser optional</li>
<li><code>parse_to!</code>: Uses the parse method from <code>std::str::FromStr</code> to convert the current input to the specified type</li>
<li><code>peek!</code>: Returns a result without consuming the input</li>
<li><code>recognize!</code>: If the child parser was successful, return the consumed input as the produced value</li>
<li><code>consumed()</code>: If the child parser was successful, return a tuple of the consumed input and the produced output.</li>
<li><code>return_error!</code>: Prevents backtracking if the child parser fails</li>
<li><code>tap!</code>: Allows access to the parser's result without affecting it</li>
<li><code>verify!</code>: Returns the result of the child parser if it satisfies a verification function</li>
</ul>
<h2 id="6-8-error-management-and-debugging">6.8 Error management and debugging</h2>
<ul>
<li><code>add_return_error!</code>: Add an error if the child parser fails</li>
<li><code>dbg!</code>: Prints a message if the parser fails</li>
<li><code>dbg_dmp!</code>: Prints a message and the input if the parser fails</li>
<li><code>error_node_position!</code>: Creates a parse error from a <code>nom::ErrorKind</code>, the position in the input and the next error in the parsing tree. If the <code>verbose-errors</code> feature is not activated, it defaults to only the error code</li>
<li><code>error_position!</code>: Creates a parse error from a <code>nom::ErrorKind</code> and the position in the input. If the <code>verbose-errors</code> feature is not activated, it defaults to only the error code</li>
<li><code>fix_error!</code>: Translate parser result from <code>IResult</code> to <code>IResult</code> with a custom type</li>
</ul>
<h2 id="6-9-text-parsing">6.9 Text parsing</h2>
<ul>
<li><code>escaped!</code>: Matches a byte string with escaped characters</li>
<li><code>escaped_transform!</code>: Matches a byte string with escaped characters, and returns a new string with the escaped characters replaced</li>
</ul>
<h2 id="6-10-binary-format-parsing">6.10 Binary format parsing</h2>
<ul>
<li><code>length_data!</code>: Gets a number from the first parser, then takes a subslice of the input of that size, and returns that subslice</li>
<li><code>length_bytes!</code>: Alias for length_data</li>
<li><code>length_value!</code>: Gets a number from the first parser, takes a subslice of the input of that size, then applies the second parser on that subslice. If the second parser returns <code>Incomplete</code>, <code>length_value!</code> will return an error</li>
</ul>
<h2 id="6-11-bit-stream-parsing">6.11 Bit stream parsing</h2>
<ul>
<li><code>bits!</code>: Transforms the current input type (byte slice <code>&amp;[u8]</code>) to a bit stream on which bit specific parsers and more general combinators can be applied</li>
<li><code>bytes!</code>: Transforms its bits stream input back into a byte slice for the underlying parser</li>
<li><code>tag_bits!</code>: Matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified</li>
<li><code>take_bits!</code>: Generates a parser consuming the specified number of bits</li>
</ul>
<h2 id="6-12-remaining-combinators">6.12 Remaining combinators</h2>
<ul>
<li><code>apply!</code>: Emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></li>
<li><code>call!</code>: Used to wrap common expressions and function as macros</li>
<li><code>method!</code>: Makes a method from a parser combination</li>
<li><code>named!</code>: Makes a function from a parser combination</li>
<li><code>named_args!</code>: Makes a function from a parser combination with arguments</li>
<li><code>named_attr!</code>: Makes a function from a parser combination, with attributes</li>
<li><code>try_parse!</code>: A bit like <code>std::try!</code>, this macro will return the remaining input and parsed value if the child parser returned <code>Ok</code>, and will do an early return for <code>Error</code> and <code>Incomplete</code>. This can provide more flexibility than <code>do_parse!</code> if needed</li>
<li><code>success</code>: Returns a value without consuming any input, always succeeds</li>
</ul>
<h2 id="6-13-character-test-functions">6.13 Character test functions</h2>
<p>Use these functions with a combinator like <code>take_while!</code>:</p>
<ul>
<li><code>is_alphabetic</code>: Tests if byte is ASCII alphabetic: <code>[A-Za-z]</code></li>
<li><code>is_alphanumeric</code>: Tests if byte is ASCII alphanumeric: <code>[A-Za-z0-9]</code></li>
<li><code>is_digit</code>: Tests if byte is ASCII digit: <code>[0-9]</code></li>
<li><code>is_hex_digit</code>: Tests if byte is ASCII hex digit: <code>[0-9A-Fa-f]</code></li>
<li><code>is_oct_digit</code>: Tests if byte is ASCII octal digit: <code>[0-7]</code></li>
<li><code>is_space</code>: Tests if byte is ASCII space or tab: <code>[ \t]</code></li>
<li><code>alpha</code>: Recognizes one or more lowercase and uppercase alphabetic characters: <code>[a-zA-Z]</code></li>
<li><code>alphanumeric</code>: Recognizes one or more numerical and alphabetic characters: <code>[0-9a-zA-Z]</code></li>
<li><code>anychar</code>: </li>
<li><code>begin</code>: </li>
<li><code>crlf</code>: </li>
<li><code>digit</code>: Recognizes one or more numerical characters: <code>[0-9]</code></li>
<li><code>double</code>: Recognizes floating point number in a byte string and returns a <code>f64</code></li>
<li><code>eol</code>: </li>
<li><code>float</code>: Recognizes floating point number in a byte string and returns a <code>f32</code></li>
<li><code>hex_digit</code>: Recognizes one or more hexadecimal numerical characters: <code>[0-9A-Fa-f]</code></li>
<li><code>hex_u32</code>: Recognizes a hex-encoded integer</li>
<li><code>line_ending</code>: Recognizes an end of line (both <code>\n</code> and <code>\r\n</code>)</li>
<li><code>multispace</code>: Recognizes one or more spaces, tabs, carriage returns and line feeds</li>
<li><code>newline</code>: Matches a newline character <code>\n</code></li>
<li><code>non_empty</code>: Recognizes non empty buffers</li>
<li><code>not_line_ending</code>: </li>
<li><code>oct_digit</code>: Recognizes one or more octal characters: <code>[0-7]</code></li>
<li><code>rest</code>: Return the remaining input</li>
<li><code>shift</code>: </li>
<li><code>sized_buffer</code>: </li>
<li><code>space</code>: Recognizes one or more spaces and tabs</li>
<li><code>tab</code>: Matches a tab character <code>\t</code></li>
</ul>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <!-- <a href="https:&#x2F;&#x2F;xjump.me&#x2F;tags&#x2F;all&#x2F;">#all</a> -->
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;xjump.me&#x2F;20200120-proxy&#x2F;">‹ Proxy Tips</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;xjump.me&#x2F;20210108-io-latency-compared&#x2F;">IO操作性能对照 ›</a>
                    
                    
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https:&#x2F;&#x2F;xjump.me&#x2F;even.js" ></script>
      
    </body>

</html>
